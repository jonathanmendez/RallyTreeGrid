<!DOCTYPE html>
<html>
<head>
    <title>TreeGrid</title>

    <script type="text/javascript" src="/apps/2.0p5/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                /**
 * FiltersFeature is a grid {@link Ext.grid.feature.Feature feature} that allows for a slightly more
 * robust representation of filtering than what is provided by the default store.
 *
 * Filtering is adjusted by the user using the grid's column header menu (this menu can be
 * disabled through configuration). Through this menu users can configure, enable, and
 * disable filters for each column.
 *
 * #Features#
 *
 * ##Filtering implementations:##
 *
 * Default filtering for Strings, Numeric Ranges, Date Ranges, Lists (which can be backed by a
 * {@link Ext.data.Store}), and Boolean. Additional custom filter types and menus are easily
 * created by extending {@link Ext.ux.grid.filter.Filter}.
 *
 * ##Graphical Indicators:##
 *
 * Columns that are filtered have {@link #filterCls a configurable css class} applied to the column headers.
 *
 * ##Automatic Reconfiguration:##
 *
 * Filters automatically reconfigure when the grid 'reconfigure' event fires.
 *
 * ##Stateful:##
 *
 * Filter information will be persisted across page loads by specifying a `stateId`
 * in the Grid configuration.
 *
 * The filter collection binds to the {@link Ext.grid.Panel#beforestaterestore beforestaterestore}
 * and {@link Ext.grid.Panel#beforestatesave beforestatesave} events in order to be stateful.
 *
 * ##GridPanel Changes:##
 *
 * - A `filters` property is added to the GridPanel using this feature.
 * - A `filterupdate` event is added to the GridPanel and is fired upon onStateChange completion.
 *
 * ##Server side code examples:##
 *
 * - [PHP](http://www.vinylfox.com/extjs/grid-filter-php-backend-code.php) - (Thanks VinylFox)
 * - [Ruby on Rails](http://extjs.com/forum/showthread.php?p=77326#post77326) - (Thanks Zyclops)
 * - [Ruby on Rails](http://extjs.com/forum/showthread.php?p=176596#post176596) - (Thanks Rotomaul)
 *
 * #Example usage:#
 *
 *     var store = Ext.create('Ext.data.Store', {
 *         pageSize: 15
 *         ...
 *     });
 *
 *     var filtersCfg = {
 *         ftype: 'filters',
 *         autoReload: false, //don't reload automatically
 *         local: true, //only filter locally
 *         // filters may be configured through the plugin,
 *         // or in the column definition within the headers configuration
 *         filters: [{
 *             type: 'numeric',
 *             dataIndex: 'id'
 *         }, {
 *             type: 'string',
 *             dataIndex: 'name'
 *         }, {
 *             type: 'numeric',
 *             dataIndex: 'price'
 *         }, {
 *             type: 'date',
 *             dataIndex: 'dateAdded'
 *         }, {
 *             type: 'list',
 *             dataIndex: 'size',
 *             options: ['extra small', 'small', 'medium', 'large', 'extra large'],
 *             phpMode: true
 *         }, {
 *             type: 'boolean',
 *             dataIndex: 'visible'
 *         }]
 *     };
 *
 *     var grid = Ext.create('Ext.grid.Panel', {
 *          store: store,
 *          columns: ...,
 *          features: [filtersCfg],
 *          height: 400,
 *          width: 700,
 *          bbar: Ext.create('Ext.PagingToolbar', {
 *              store: store
 *          })
 *     });
 *
 *     // a filters property is added to the GridPanel
 *     grid.filters
 */
Ext.define('Ext.ux.grid.FiltersFeature', {
    extend: 'Ext.grid.feature.Feature',
    alias: 'feature.filters',
    uses: [
        'Ext.ux.grid.menu.ListMenu',
        'Ext.ux.grid.menu.RangeMenu',
        'Ext.ux.grid.filter.BooleanFilter',
        'Ext.ux.grid.filter.DateFilter',
        'Ext.ux.grid.filter.DateTimeFilter',
        'Ext.ux.grid.filter.ListFilter',
        'Ext.ux.grid.filter.NumericFilter',
        'Ext.ux.grid.filter.StringFilter'
    ],

    /**
     * @cfg {Boolean} autoReload
     * Defaults to true, reloading the datasource when a filter change happens.
     * Set this to false to prevent the datastore from being reloaded if there
     * are changes to the filters.  See <code>{@link #updateBuffer}</code>.
     */
    autoReload : true,
    /**
     * @cfg {Boolean} encode
     * Specify true for {@link #buildQuery} to use Ext.util.JSON.encode to
     * encode the filter query parameter sent with a remote request.
     * Defaults to false.
     */
    /**
     * @cfg {Array} filters
     * An Array of filters config objects. Refer to each filter type class for
     * configuration details specific to each filter type. Filters for Strings,
     * Numeric Ranges, Date Ranges, Lists, and Boolean are the standard filters
     * available.
     */
    /**
     * @cfg {String} filterCls
     * The css class to be applied to column headers with active filters.
     * Defaults to <tt>'ux-filterd-column'</tt>.
     */
    filterCls : 'ux-filtered-column',
    /**
     * @cfg {Boolean} local
     * <tt>true</tt> to use Ext.data.Store filter functions (local filtering)
     * instead of the default (<tt>false</tt>) server side filtering.
     */
    local : false,
    /**
     * @cfg {String} menuFilterText
     * defaults to <tt>'Filters'</tt>.
     */
    menuFilterText : 'Filters',
    /**
     * @cfg {String} paramPrefix
     * The url parameter prefix for the filters.
     * Defaults to <tt>'filter'</tt>.
     */
    paramPrefix : 'filter',
    /**
     * @cfg {Boolean} showMenu
     * Defaults to true, including a filter submenu in the default header menu.
     */
    showMenu : true,
    /**
     * @cfg {String} stateId
     * Name of the value to be used to store state information.
     */
    stateId : undefined,
    /**
     * @cfg {Number} updateBuffer
     * Number of milliseconds to defer store updates since the last filter change.
     */
    updateBuffer : 500,

    // doesn't handle grid body events
    hasFeatureEvent: false,


    /** @private */
    constructor : function (config) {
        var me = this;

        config = config || {};
        Ext.apply(me, config);

        me.deferredUpdate = Ext.create('Ext.util.DelayedTask', me.reload, me);

        // Init filters
        me.filters = me.createFiltersCollection();
        me.filterConfigs = config.filters;
    },

    attachEvents: function() {
        var me = this,
            view = me.view,
            headerCt = view.headerCt,
            grid = me.getGridPanel();

        me.bindStore(view.getStore(), true);

        // Listen for header menu being created
        headerCt.on('menucreate', me.onMenuCreate, me);

        view.on('refresh', me.onRefresh, me);
        grid.on({
            scope: me,
            beforestaterestore: me.applyState,
            beforestatesave: me.saveState,
            beforedestroy: me.destroy
        });

        // Add event and filters shortcut on grid panel
        grid.filters = me;
        grid.addEvents('filterupdate');
    },

    createFiltersCollection: function () {
        return Ext.create('Ext.util.MixedCollection', false, function (o) {
            return o ? o.dataIndex : null;
        });
    },

    /**
     * @private Create the Filter objects for the current configuration, destroying any existing ones first.
     */
    createFilters: function() {
        var me = this,
            hadFilters = me.filters.getCount(),
            grid = me.getGridPanel(),
            filters = me.createFiltersCollection(),
            model = grid.store.model,
            fields = model.prototype.fields,
            field,
            filter,
            state;

        if (hadFilters) {
            state = {};
            me.saveState(null, state);
        }

        function add (dataIndex, config, filterable) {
            if (dataIndex && (filterable || config)) {
                field = fields.get(dataIndex);
                filter = {
                    dataIndex: dataIndex,
                    type: (field && field.type && field.type.type) || 'auto'
                };

                if (Ext.isObject(config)) {
                    Ext.apply(filter, config);
                }

                filters.replace(filter);
            }
        }

        // We start with filters from our config
        Ext.Array.each(me.filterConfigs, function (filterConfig) {
            add(filterConfig.dataIndex, filterConfig);
        });

        // Then we merge on filters from the columns in the grid. The columns' filters take precedence.
        Ext.Array.each(grid.columns, function (column) {
            if (column.filterable === false) {
                filters.removeAtKey(column.dataIndex);
            } else {
                add(column.dataIndex, column.filter, column.filterable);
            }
        });
        

        me.removeAll();
        if (filters.items) {
            me.initializeFilters(filters.items);
        }

        if (hadFilters) {
            me.applyState(null, state);
        }
    },

    /**
     * @private
     */
    initializeFilters: function(filters) {
        var me = this,
            filtersLength = filters.length,
            i, filter, FilterClass;

        for (i = 0; i < filtersLength; i++) {
            filter = filters[i];
            if (filter) {
                FilterClass = me.getFilterClass(filter.type);
                filter = filter.menu ? filter : new FilterClass(filter);
                me.filters.add(filter);
                Ext.util.Observable.capture(filter, this.onStateChange, this);
            }
        }
    },

    /**
     * @private Handle creation of the grid's header menu. Initializes the filters and listens
     * for the menu being shown.
     */
    onMenuCreate: function(headerCt, menu) {
        var me = this;
        me.createFilters();
        menu.on('beforeshow', me.onMenuBeforeShow, me);
    },

    /**
     * @private Handle showing of the grid's header menu. Sets up the filter item and menu
     * appropriate for the target column.
     */
    onMenuBeforeShow: function(menu) {
        var me = this,
            menuItem, filter;

        if (me.showMenu) {
            menuItem = me.menuItem;
            if (!menuItem || menuItem.isDestroyed) {
                me.createMenuItem(menu);
                menuItem = me.menuItem;
            }

            filter = me.getMenuFilter();

            if (filter) {
                menuItem.setMenu(filter.menu, false);
                menuItem.setChecked(filter.active);
                // disable the menu if filter.disabled explicitly set to true
                menuItem.setDisabled(filter.disabled === true);
            }
            menuItem.setVisible(!!filter);
            this.sep.setVisible(!!filter);
        }
    },


    createMenuItem: function(menu) {
        var me = this;
        me.sep  = menu.add('-');
        me.menuItem = menu.add({
            checked: false,
            itemId: 'filters',
            text: me.menuFilterText,
            listeners: {
                scope: me,
                checkchange: me.onCheckChange,
                beforecheckchange: me.onBeforeCheck
            }
        });
    },

    getGridPanel: function() {
        return this.view.up('gridpanel');
    },

    /**
     * @private
     * Handler for the grid's beforestaterestore event (fires before the state of the
     * grid is restored).
     * @param {Object} grid The grid object
     * @param {Object} state The hash of state values returned from the StateProvider.
     */
    applyState : function (grid, state) {
        var me = this,
            key, filter;
        me.applyingState = true;
        me.clearFilters();
        if (state.filters) {
            for (key in state.filters) {
                if (state.filters.hasOwnProperty(key)) {
                    filter = me.filters.get(key);
                    if (filter) {
                        filter.setValue(state.filters[key]);
                        filter.setActive(true);
                    }
                }
            }
        }
        me.deferredUpdate.cancel();
        if (me.local) {
            me.reload();
        }
        delete me.applyingState;
        delete state.filters;
    },

    /**
     * Saves the state of all active filters
     * @param {Object} grid
     * @param {Object} state
     * @return {Boolean}
     */
    saveState : function (grid, state) {
        var filters = {};
        this.filters.each(function (filter) {
            if (filter.active) {
                filters[filter.dataIndex] = filter.getValue();
            }
        });
        return (state.filters = filters);
    },

    /**
     * @private
     * Handler called by the grid 'beforedestroy' event
     */
    destroy : function () {
        var me = this;
        Ext.destroyMembers(me, 'menuItem', 'sep');
        me.removeAll();
        me.clearListeners();
    },

    /**
     * Remove all filters, permanently destroying them.
     */
    removeAll : function () {
        if(this.filters){
            Ext.destroy.apply(Ext, this.filters.items);
            // remove all items from the collection
            this.filters.clear();
        }
    },


    /**
     * Changes the data store bound to this view and refreshes it.
     * @param {Ext.data.Store} store The store to bind to this view
     */
    bindStore : function(store) {
        var me = this;

        // Unbind from the old Store
        if (me.store && me.storeListeners) {
            me.store.un(me.storeListeners);
        }

        // Set up correct listeners
        if (store) {
            me.storeListeners = {
                scope: me
            };
            if (me.local) {
                me.storeListeners.load = me.onLoad;
            } else {
                me.storeListeners['before' + (store.buffered ? 'prefetch' : 'load')] = me.onBeforeLoad;
            }
            store.on(me.storeListeners);
        } else {
            delete me.storeListeners;
        }
        me.store = store;
    },

    /**
     * @private
     * Get the filter menu from the filters MixedCollection based on the clicked header
     */
    getMenuFilter : function () {
        var header = this.view.headerCt.getMenu().activeHeader;
        return header ? this.filters.get(header.dataIndex) : null;
    },

    /** @private */
    onCheckChange : function (item, value) {
        this.getMenuFilter().setActive(value);
    },

    /** @private */
    onBeforeCheck : function (check, value) {
        return !value || this.getMenuFilter().isActivatable();
    },

    /**
     * @private
     * Handler for all events on filters.
     * @param {String} event Event name
     * @param {Object} filter Standard signature of the event before the event is fired
     */
    onStateChange : function (event, filter) {
        if (event !== 'serialize') {
            var me = this,
                grid = me.getGridPanel();

            if (filter == me.getMenuFilter()) {
                me.menuItem.setChecked(filter.active, false);
            }

            if ((me.autoReload || me.local) && !me.applyingState) {
                me.deferredUpdate.delay(me.updateBuffer);
            }
            me.updateColumnHeadings();

            if (!me.applyingState) {
                grid.saveState();
            }
            grid.fireEvent('filterupdate', me, filter);
        }
    },

    /**
     * @private
     * Handler for store's beforeload event when configured for remote filtering
     * @param {Object} store
     * @param {Object} options
     */
    onBeforeLoad : function (store, options) {
        options.params = options.params || {};
        this.cleanParams(options.params);
        var params = this.buildQuery(this.getFilterData());
        Ext.apply(options.params, params);
    },

    /**
     * @private
     * Handler for store's load event when configured for local filtering
     * @param {Object} store
     */
    onLoad : function (store) {
        store.filterBy(this.getRecordFilter());
    },

    /**
     * @private
     * Handler called when the grid's view is refreshed
     */
    onRefresh : function () {
        this.updateColumnHeadings();
    },

    /**
     * Update the styles for the header row based on the active filters
     */
    updateColumnHeadings : function () {
        var me = this,
            headerCt = me.view.headerCt;
        if (headerCt) {
            headerCt.items.each(function(header) {
                var filter = me.getFilter(header.dataIndex);
                header[filter && filter.active ? 'addCls' : 'removeCls'](me.filterCls);
            });
        }
    },

    /** @private */
    reload : function () {
        var me = this,
            store = me.view.getStore();

        if (me.local) {
            store.clearFilter(true);
            store.filterBy(me.getRecordFilter());
            store.sort();
        } else {
            me.deferredUpdate.cancel();
            if (store.buffered) {
                store.pageMap.clear();
            }
            store.loadPage(1);
        }
    },

    /**
     * Method factory that generates a record validator for the filters active at the time
     * of invokation.
     * @private
     */
    getRecordFilter : function () {
        var f = [], len, i;
        this.filters.each(function (filter) {
            if (filter.active) {
                f.push(filter);
            }
        });

        len = f.length;
        return function (record) {
            for (i = 0; i < len; i++) {
                if (!f[i].validateRecord(record)) {
                    return false;
                }
            }
            return true;
        };
    },

    /**
     * Adds a filter to the collection and observes it for state change.
     * @param {Object/Ext.ux.grid.filter.Filter} config A filter configuration or a filter object.
     * @return {Ext.ux.grid.filter.Filter} The existing or newly created filter object.
     */
    addFilter : function (config) {
        var me = this,
            columns = me.getGridPanel().columns,
            i, columnsLength, column, filtersLength, filter;

        
        for (i = 0, columnsLength = columns.length; i < columnsLength; i++) {
            column = columns[i];
            if (column.dataIndex === config.dataIndex) {
                column.filter = config;
            }
        }
        
        if (me.view.headerCt.menu) {
            me.createFilters();
        } else {
            // Call getMenu() to ensure the menu is created, and so, also are the filters. We cannot call
            // createFilters() withouth having a menu because it will cause in a recursion to applyState()
            // that ends up to clear all the filter values. This is likely to happen when we reorder a column
            // and then add a new filter before the menu is recreated.
            me.view.headerCt.getMenu();
        }
        
        for (i = 0, filtersLength = me.filters.items.length; i < filtersLength; i++) {
            filter = me.filters.items[i];
            if (filter.dataIndex === config.dataIndex) {
                return filter;
            }
        }
    },

    /**
     * Adds filters to the collection.
     * @param {Array} filters An Array of filter configuration objects.
     */
    addFilters : function (filters) {
        if (filters) {
            var me = this,
                i, filtersLength;
            for (i = 0, filtersLength = filters.length; i < filtersLength; i++) {
                me.addFilter(filters[i]);
            }
        }
    },

    /**
     * Returns a filter for the given dataIndex, if one exists.
     * @param {String} dataIndex The dataIndex of the desired filter object.
     * @return {Ext.ux.grid.filter.Filter}
     */
    getFilter : function (dataIndex) {
        return this.filters.get(dataIndex);
    },

    /**
     * Turns all filters off. This does not clear the configuration information
     * (see {@link #removeAll}).
     */
    clearFilters : function () {
        this.filters.each(function (filter) {
            filter.setActive(false);
        });
    },

    getFilterItems: function () {
        var me = this;

        // If there's a locked grid then we must get the filter items for each grid.
        if (me.lockingPartner) {
            return me.filters.items.concat(me.lockingPartner.filters.items);
        }

        return me.filters.items;
    },

    /**
     * Returns an Array of the currently active filters.
     * @return {Array} filters Array of the currently active filters.
     */
    getFilterData : function () {
        var items = this.getFilterItems(),
            filters = [],
            n, nlen, item, d, i, len;

        for (n = 0, nlen = items.length; n < nlen; n++) {
            item = items[n];
            if (item.active) {
                d = [].concat(item.serialize());
                for (i = 0, len = d.length; i < len; i++) {
                    filters.push({
                        field: item.dataIndex,
                        data: d[i]
                    });
                }
            }
        }
        return filters;
    },

    /**
     * Function to take the active filters data and build it into a query.
     * The format of the query depends on the {@link #encode} configuration:
     *
     *   - `false` (Default) :
     *     Flatten into query string of the form (assuming <code>{@link #paramPrefix}='filters'</code>:
     *
     *         filters[0][field]="someDataIndex"&
     *         filters[0][data][comparison]="someValue1"&
     *         filters[0][data][type]="someValue2"&
     *         filters[0][data][value]="someValue3"&
     *
     *
     *   - `true` :
     *     JSON encode the filter data
     *
     *         {filters:[{"field":"someDataIndex","comparison":"someValue1","type":"someValue2","value":"someValue3"}]}
     *
     * Override this method to customize the format of the filter query for remote requests.
     *
     * @param {Array} filters A collection of objects representing active filters and their configuration.
     * Each element will take the form of {field: dataIndex, data: filterConf}. dataIndex is not assured
     * to be unique as any one filter may be a composite of more basic filters for the same dataIndex.
     *
     * @return {Object} Query keys and values
     */
    buildQuery : function (filters) {
        var p = {}, i, f, root, dataPrefix, key, tmp,
            len = filters.length;

        if (!this.encode){
            for (i = 0; i < len; i++) {
                f = filters[i];
                root = [this.paramPrefix, '[', i, ']'].join('');
                p[root + '[field]'] = f.field;

                dataPrefix = root + '[data]';
                for (key in f.data) {
                    p[[dataPrefix, '[', key, ']'].join('')] = f.data[key];
                }
            }
        } else {
            tmp = [];
            for (i = 0; i < len; i++) {
                f = filters[i];
                tmp.push(Ext.apply(
                    {},
                    {field: f.field},
                    f.data
                ));
            }
            // only build if there is active filter
            if (tmp.length > 0){
                p[this.paramPrefix] = Ext.JSON.encode(tmp);
            }
        }
        return p;
    },

    /**
     * Removes filter related query parameters from the provided object.
     * @param {Object} p Query parameters that may contain filter related fields.
     */
    cleanParams : function (p) {
        // if encoding just delete the property
        if (this.encode) {
            delete p[this.paramPrefix];
        // otherwise scrub the object of filter data
        } else {
            var regex, key;
            regex = new RegExp('^' + this.paramPrefix + '\\[[0-9]+\\]');
            for (key in p) {
                if (regex.test(key)) {
                    delete p[key];
                }
            }
        }
    },

    /**
     * Function for locating filter classes, overwrite this with your favorite
     * loader to provide dynamic filter loading.
     * @param {String} type The type of filter to load ('Filter' is automatically
     * appended to the passed type; eg, 'string' becomes 'StringFilter').
     * @return {Function} The Ext.ux.grid.filter.Class
     */
    getFilterClass : function (type) {
        // map the supported Ext.data.Field type values into a supported filter
        switch(type) {
            case 'auto':
              type = 'string';
              break;
            case 'int':
            case 'float':
              type = 'numeric';
              break;
            case 'bool':
              type = 'boolean';
              break;
        }
        return Ext.ClassManager.getByAlias('gridfilter.' + type);
    }
});

                Ext.define('MyApp.feature.TreeFiltersFeature', {
  extend: 'Ext.ux.grid.FiltersFeature',
  alias: 'feature.treefilters',

  //overridden method
  getGridPanel: function () {
    return this.getTreePanel();
  },

  getTreePanel: function () {
    return this.view.up('treepanel');
  },

  //overridden method
  reload: function () {
    var treeStore = this.view.getTreeStore();
    if (this.local) {
      treeStore.clearFilter(true);
      treeStore.filter([
        {
          fn: this.getRecordFilter(),
          scope: this
        }
      ]);
    } else {
      this.deferredUpdate.cancel();
      treeStore.loadPage(1);
    }
  }

});

                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * @private
     * Parses an ALM compatible query string
     */

    Ext.define('Rally.data.util.QueryStringParser', {

        config: {
            /**
             * @cfg {String} (required)
             * The string to parse into a {Rally.data.QueryFilter}
             */
            string: null
        },

        constructor: function (config) {
            this.initConfig(config);
        },

        /**
         * @private
         * {RegEx} The operation regex
         */
        operations: /^\s*(=|!=|<=|>=|<|>|AND|OR|[!]?CONTAINS|\(|\))/i,

        /**
         * @private
         * {RegEx} The quote regex
         */
        quotes: /^\s*"([^"|\\"]+)"/,

        /**
         * @private
         * {RegEx} The word regex
         */
        words: /^\s*([^ \)]+)/,

        /**
         * @private
         * {Array[String]} Array of valid operations to parse from a string expression
         */
        operators: ['=','!=','<=','>=','<','>','AND','OR','!CONTAINS','CONTAINS'],

        /**
         * Find the next token
         * @private
         * @return {String}
         */
        peek: function () {
            var string = Ext.String.trim(this.string),
                matches;

            matches = this.operations.exec(string);
            if (matches && matches.length) {
                return matches[1];
            }

            matches = this.quotes.exec(string);
            if (matches && matches.length) {
                return matches[1];
            }

            matches = this.words.exec(string);
            if (matches && matches.length) {
                return matches[1];
            }
            return '';
        },

        /**
         * Remove the stringToFind from the string to move onto the next token
         * @private
         * @param {String} stringToFind
         * @return {String}
         */
        consume: function (stringToFind) {
            string = Ext.String.trim(this.string);
            this.string = string.substring(string.indexOf(stringToFind) + stringToFind.length);
        },

        /**
         * Parse the next term in the string
         * @private
         * @return {String|Rally.data.QueryFilter}
         */
        parseNextTerm: function () {
            var nextTerm = this.peek();
            if (nextTerm === '(') {
                this.consume('(');
                var expression = this.applyOperators(this.operators);
                if (!(expression instanceof Rally.data.QueryFilter)) {
                    throw new Error('Invalid expression starting at "' + expression + '"');
                }
                this.consume(')');
                return expression;
            } else {
                this.consume(nextTerm);
                return nextTerm;
            }
        },

        applyOperators: function (operators, operator) {
            if (!operators.length) {
                return this.parseNextTerm();
            }

            if (!operator) {
                operator = operators[0];
            }

            var property = this.applyOperators(operators.slice(1));

            while (this.peek() === operator) {
                this.consume(operator);
                var value = this.applyOperators(operators.slice(1));
                property = Ext.create('Rally.data.QueryFilter', {
                    property: property,
                    operator: operator,
                    value: this._convertToType(value)
                });
            }
            return property;
        },

        /**
         * Make sure we are aware of types
         * @param value
         * @private
         */
        _convertToType: function (value) {
            if (!Ext.isString(value)) {
                return value;
            }
            if (value.toLowerCase() === 'true') {
                return true;
            } else if (value.toLowerCase() === 'false') {
                return false;
            } else if ((value.length > 0) && !isNaN(+value)) {
                return +value;
            } else {
                return value;
            }
        },

        /**
         * Convert the operations in the provided string to uppercase
         * @private
         * @return {String}
         */
        _operatorsToUpperCase: function (string) {
            string = string.replace(/\)\s+and\s+\(/ig, ') AND (');
            string = string.replace(/\)\s+or\s+\(/ig, ') OR (');
            return string.replace(/\b(contains)/ig, 'CONTAINS');
        },

        /**
         * Parse the expression provided if possible
         * @return {Rally.data.QueryFilter}
         */
        parseExpression: function () {
            var originalString = this.string;

            if (this.string === null) {
                throw new Error ('Cannot parse null query: ' + originalString);
            }

            this.string = Ext.String.trim(this.string);
            this.string = this._operatorsToUpperCase(this.string);

            var filter = this.parseNextTerm();

            if (!(filter instanceof Rally.data.QueryFilter)) {
                throw new Error ('Failed to parse query: ' + originalString);
            }

            var trailingQuery = this.parseNextTerm();
            if(trailingQuery) {
                throw new Error ('Failed to parse query: found trailing info at "' + trailingQuery + '". Make sure you wrap the whole query in parentheses.');
            }

            return filter;
        }

    });
})();

                (function (global) {
  Ext.define("Rally.data.WsapiTreeProxy", {
    requires: ["Rally.data.WsapiReader"],

    extend: "Rally.data.WsapiRestProxy",

    topLevelModels: null, //["HierarchicalRequirement"],
    childModels: null, //["HierarchicalRequirement"],
    isRoot: false,
    model: null,

    constructor: function ctor(config) {
      var me = this;

      Ext.apply(me, config);
      me.reader = Ext.create("Rally.data.WsapiReader",  {
        root: "HierarchicalRequirement",
        totalProperty: "TotalResultCount"
      });

      //console.log("For Artifacts", me.topLevelModels, me.childModels);
      //debugger;
    },

    read: function read(operation, callback, scope) {
      var me = this;

      //console.log("Calling WTP Read", operation);

      if (me.isRoot) {
        me._readRoot(operation, callback, scope);
      } else {
        me._readChildren(operation, callback, scope);
      }
    },

    _readRoot: function _readRoot(operation, callback, scope) {
      var loadedArtifacts = {},
          me = this,
          processCB = Ext.bind(this._processResults, {filterFn: me.filterFn, loadedArtifacts: loadedArtifacts, operation: operation, callback: callback, scope: scope}),
          i= 0, ii = me.topLevelModels.length;

      //console.log("Reading Root");

      var iHateJsScoping = function iHateJsScoping(type) {
        var sorter = [{
          property: "Rank",
          direction: "ASC"
        }];

        Rally.data.TreeModelFactory.getModel({
          type: type,
          canExpandFn: me.canExpandFn,
          success: function onSuccess(model) {
            var query = model.buildParentQueryFn(model, null);

            if (me.wsapiStoreOptions.query) {
              query = query.and(me.wsapiStoreOptions.query);
            }

            var wsapi = Ext.create("Rally.data.WsapiDataStore", {
              autoLoad: false,
              model: model,
              pageSize: me.wsapiStoreOptions.limit,
              startPage: me.wsapiStoreOptions.page,
              page: me.wsapiStoreOptions.page,
              start: me.wsapiStoreOptions.start,
              limit: me.wsapiStoreOptions.limit,
              isPaging: me.wsapiStoreOptions.isPaging,
              filters: query,
              sorters: model.superclass.self.typeName.toLowerCase() !== "testcase" ? sorter : null,
              listeners: {
                load: function loaded(store, data, success) {
                  processCB(store, data, type);
                }
              }
            });

            wsapi.loadPage(me.wsapiStoreOptions.page);
          }
        });
      };

      for (; i < ii; i++) {
        loadedArtifacts[me.topLevelModels[i].toLowerCase()] = 0;

        iHateJsScoping(me.topLevelModels[i].toLowerCase());
      }
    },

    _readChildren: function _readChildren(operation, callback, scope) {
      var loadedArtifacts = {},
          me = this,
          processCB = Ext.bind(this._processResults, {
            filterFn: me.filterFn, 
            loadedArtifacts: loadedArtifacts, 
            operation: operation, 
            callback: callback, 
            scope: scope}),
          i= 0, ii = me.childModels.length;

      //console.log("Reading Children");

      var iHateJsScoping = function iHateJsScoping(type) {
        var sorter = [{
          property: "Rank",
          direction: "ASC"
        }];

        Rally.data.TreeModelFactory.getModel({
          canExpandFn: me.canExpandFn,
          type: type,
          success: function onSuccess(model) {
            Ext.create("Rally.data.WsapiDataStore", {
              autoLoad: true,
              filters: model.buildParentQueryFn(model, operation.node),
              sorters: model.superclass.self.typeName.toLowerCase() !== "testcase" ? sorter : null,
              model: model,
              listeners: {
                load: function loaded(store, data, success) {
                  //console.log("Loaded Children", type, store, data, success);
                  processCB(store, data, type);
                }
              }
            });
          }
        });
      };

      for (; i < ii; i++) {
        //console.log("Fetching children of type", me.childModels[i], i, ii);
        loadedArtifacts[me.childModels[i].toLowerCase()] = 0;

        iHateJsScoping(me.childModels[i].toLowerCase());
      }

    },

    _processResults: function (store, data, artifactType) {
      //console.log("Loaded " + artifactType, data, this);

      if (this.loadedArtifacts[artifactType.toLowerCase()]) {
        //console.log("Already processed, abort");
        return;
      }

      if (typeof this.operation.resultSet === "undefined") {
        this.operation.resultSet = [];
      }
      if (typeof this.operation.totalResultCount === "undefined") {
        this.operation.totalResultCount = 0;
      }

      var i, ii, k, done = true;
      this.operation.totalResultCount = this.operation.totalResultCount + store.getTotalCount();

      if (data) {
        for (i = 0, ii = data.length; i < ii; i ++) {
          //console.log("Data processing", typeof data[i], data[i]);

          data[i].data.cls = data[i].raw._type.split("/").join("").toLowerCase();
          data[i].data.href = Rally.util.Navigation.createRallyDetailUrl(data[i].data);
          if (data[i].data.href.indexOf("#") !== 1) {
            data[i].data.href = "/#" + data[i].data.href;
          }
          data[i].data.hrefTarget = "_top";

          if (this.filterFn(data[i])) {
            this.operation.resultSet.push(data[i]);
          }
        }
      }

      this.loadedArtifacts[artifactType] = 1;

      for (k in this.loadedArtifacts) {
        if (this.loadedArtifacts.hasOwnProperty(k)) {
          done = done && this.loadedArtifacts[k];
        }
      }

      if (done) {
        //console.log("Done");

        this.operation.records = this.operation.resultSet;
        this.operation.setCompleted();
        this.operation.setSuccessful();

        //console.dir(this.operation);
        //debugger;

        Ext.callback(this.callback, this.scope || this, [this.operation]);
      }
    }

    //getProxy: function () {
      //return {buildExtractors: function() {}};
    //}
  });
}(this));

                (function (global) {
  var trm = Ext.define("Rally.data.TreeRootModel", {
    requires: [
      "Ext.data.NodeInterface",
      "Rally.data.WsapiTreeProxy"
    ],

    extend: "Ext.data.Model",

    constructor: function ctor(options) {
      var me = this,
          o = {};

      Ext.apply(o, {
        topLevelModels: ["HierarchicalRequirement"]
      });
      Ext.apply(o, options);

      //console.log("TreeRootModel", o, options);

      me.proxy = Ext.create("Rally.data.WsapiTreeProxy", {
        topLevelModels: o.topLevelModels,
        isRoot: true
      });

      me.callParent([options]);
    }
  });

  Ext.data.NodeInterface.decorate(trm);
}(this));

                (function(global) {

  Ext.define('Rally.data.TreeModelFactory', {
    requires: ['Ext.data.NodeInterface', 'Rally.data.ModelFactory'],

    singleton: true,

    getModel: function getModel(options) {
      var me = this,
          cb = options.success || function noop() {},
          canExpandFn = options.canExpandFn,
          buildParentQueryFn = options.buildParentQueryFn;

      delete options.canExpandFn;
      delete options.buildParentQueryFn;

      options.success = function onTreeModelSuccess(model) {
        var treeModel = me.createTreeModel(model, {canExpand: canExpandFn, buildParentQueryFn: buildParentQueryFn});
        cb(treeModel);
      };

      //debugger;

      Rally.data.ModelFactory.getModel(options);

    },

    getModels: function getModels(options) {
      var me = this,
          cb = options.success || function noop() {},
          canExpandFn = options.canExpandFn,
          buildParentQueryFn = options.buildParentQueryFn;

      delete options.canExpandFn;
      delete options.buildParentQueryFn;

      //console.log("Getting Models");
      options.success = function onTreeModelSuccess(models) {
        var treeModels = {},
            modelName;
        
        //console.log("The models", models);
        for (modelName in models) {
          if (models.hasOwnProperty(modelName)) {
            treeModels[modelName] = 
              me.createTreeModel(models[modelName], 
                                 {canExpand: canExpandFn, buildParentQueryFn: buildParentQueryFn});

            
          }
        }

        cb(treeModels);
      };

      //debugger;

      Rally.data.ModelFactory.getModels(options);
    },

    createTreeModel: function createTreeModel(baseModel, options) {
        var o = {},
            canExpandFn = options.canExpandFn,
            buildParentQueryFn = options.buildParentQueryFn,
            treeModel;

        if (typeof canExpandFn !== "function") {
          canExpandFn = function defaultCanExpandFn(rec) {
            //console.log("Checking Can Expand");
            var names = rec.self.getChildFieldNames(),
                canExpand = false,
                i, ii;

            //console.log("Can Expand Fields", names);

            for (i = 0, ii = names.length; i < ii; i++) {
              if (rec.raw.hasOwnProperty(names[i])) {
                canExpand = canExpand || rec.raw[names[i]].length > 0;
              }
            }

            return canExpand;
          };
        }

        if (typeof buildParentQueryFn !== "function") {
          buildParentQueryFn = function defaultBuildParentQueryFn(model, parentRec) {
            var names = model.getParentFieldNames(),
                filteredNames = [],
                modelType = model.superclass.self.typeName.toLowerCase(),
                parentType,
                parentRef,
                query,
                queryMeth = parentRec ? "or" : "and",
                i, ii;

            if (parentRec) {
              parentType = parentRec.self.superclass.self.typeName.toLowerCase();
              parentRef = parentRec.raw._ref;
            } else {
              parentType = null;
              parentRef = null;
            }

            // Remove potential Parent names when they don't exist on the model
            for (i = 0, ii = names.length; i < ii; i++) {
              if (model.getField(names[i])) {
                filteredNames.push(names[i]);
              }
            }

            if (filteredNames.length === 0) {
              return Ext.create("Rally.data.QueryFilter", {
                property: "ObjectID",
                operator: "!=",
                value: "0"
              });
            }

            // Let the crappy if statement begin!!!
            if (modelType.indexOf("portfolioitem") >= 0) {
              if (parentType) {
                //console.log("The Parent type is", parentType);
                query = Ext.create("Rally.data.QueryFilter", {
                  property: "Parent",
                  operator: "=",
                  value: parentRef
                });
              } else {
                query = Ext.create("Rally.data.QueryFilter", {
                  property: "ObjectID",
                  operator: "!=",
                  value: "0"
                });
              }
            } else if (modelType === "hierarchicalrequirement") {
              //console.log("Create Query for Stories");
              if (parentType === modelType) {
                //console.log("Its a Story");
                query = Ext.create("Rally.data.QueryFilter", {
                  property: 'Parent',
                  operator: "=",
                  value: parentRef
                });
              } else if (parentType === null) {
                //console.log("Top level story");
                query = Ext.create("Rally.data.QueryFilter", {
                  property: 'Parent',
                  operator: "=",
                  value: "null"
                });

                //query = query.and(Ext.create("Rally.data.QueryFilter", {
                  //property: 'PortfolioItem',
                  //operator: '=',
                  //value: 'null'
                //}));
              } else if (parentType.indexOf("portfolioitem") !== -1) {
                //console.log("Its a PI");
                query = Ext.create("Rally.data.QueryFilter", {
                  property: 'PortfolioItem',
                  operator: "=",
                  value: parentRef
                });
              }
            } else {
              //console.log("Don't know what this is", modelType, parentType);
              query = Ext.create("Rally.data.QueryFilter", {
                property: filteredNames[0],
                operator: "=",
                value: parentRef
              });

              for (i = 1, ii = filteredNames.length; i < ii; i++) {
                query = query[queryMeth].call(query, Ext.create("Rally.data.QueryFilter", {
                  property: filteredNames[i],
                  operator: "=",
                  value: parentRef
                }));
              }
            }

            //console.log("Query for ", model.modelName, query.toString());

            return query;
          };
        }

        Ext.applyIf(o, {
          extend: baseModel,

          constructor: function ctor(config) {
            //console.log("Tree Model Config options", config);
            this.callParent([config]);
          },

          statics: {
            canExpandFn: canExpandFn,

            buildParentQueryFn: buildParentQueryFn,

            getParentFieldNames: function getParentFieldNames() {
              var typeName = baseModel.typeName.toLowerCase();

              if ({"task": 1, "testcase": 1}.hasOwnProperty(typeName)) {
                return ["WorkProduct"];
              } else if ({"defect": 1}.hasOwnProperty(typeName)) {
                return ["Requirement"];
              } else if ({"testcasestep": 1}.hasOwnProperty(typeName)) {
                return ["TestCase"];
              } else if ({"hierarchicalrequirement": 1}.hasOwnProperty(typeName)) {
                return ["Parent", "PortfolioItem"];
              } else if ({testcasestep: 1}.hasOwnProperty(typeName)) {
                return ["TestCase"];
              } else {
                return ["Parent"];
              }
            },

            getChildFieldNames: function getChildFieldNames() {
              var typeName = baseModel.typeName.toLowerCase();

              if (typeName === "hierarchicalrequirement") {
                return ["Tasks", "Children", "Defects", "TestCases"];
              } else if (typeName === "defectsuite") {
                return ["Defects", "Tasks"];
              } else if (typeName === "defect") {
                return ["Tasks"];
              } else if (typeName === "testcase") {
                return ["Steps"];
              } else if (typeName.indexOf("portfolioitem") !== -1) {
                return ["Children", "UserStories"];
              } else {
                return ["Children"];
              }
            }
          }
        });

        treeModel = Ext.define(baseModel.modelName + ".TreeModel", o);

        Ext.data.NodeInterface.decorate(treeModel);

        var i, ii, fields = treeModel.getFields(), ssClone;

        var canExpandConvert = function canExpandConvert(v, rec) {
          return !rec.self.canExpandFn(rec);
        };

        var convertFn = function (v, rec) {
            if (rec.raw._type.toLowerCase() === "task") {
              return rec.get("State");
            } else if (rec.raw._type.toLowerCase().indexOf("portfolio") >= 0) {
              if (rec.get("State")) {
                return rec.get("State")._refObjectName;
              }

              return "";
            } else if (rec.raw.hasOwnProperty("ScheduleState")) {
              return rec.get("ScheduleState");
            } else {
              return "";
            }
        };

        for (i = 0, ii = fields.length; i < ii; i++) {
          if ({leaf: 1}.hasOwnProperty(fields[i].name)) {
            fields[i].convert = canExpandConvert;
          }

          if ({ScheduleState: 1, State: 1}.hasOwnProperty(fields[i].name)) {
            ssClone = {};

            ssClone.allowedValueType = null;
            ssClone.allowedValues = fields[i].allowedValues;
            ssClone.renderTpl = fields[i].renderTpl;

            ssClone.name = "UnifiedState";
            ssClone.convert = convertFn;
          }
        }

        if (ssClone) {
          Ext.data.NodeInterface.applyFields(treeModel, [ssClone]);
        }

        return treeModel;
    }
  });

}(this));

                (function (global) {
  var totalProcessed = 0;

  Ext.define("Rally.data.WsapiTreeStore", {
    extend: "Ext.data.TreeStore",

    topLevelModels: ["HierarchicalRequirement"],
    childModels: ["HierarchicalRequirement", "Task"],

    pageSize: 25,

    totalProcessed: 0,
    totalCount: 0,

    currentPage: 1,

    filterFn: function defaultFilterFn() { return true; },

    constructor: function wsapi_tree_store_ctor(config) {
      var me = this,
          trmConfig = {};


      Ext.apply(me, config);

      me.callParent([config]);

      //console.log("WsapiTreeStore Root Artifacts", me.topLevelModels);

      me.setRootNode(Ext.create("Rally.data.TreeRootModel", {
        topLevelModels: me.topLevelModels,
        leaf: false
      }));

      //me.proxy = Ext.create("Rally.data.WsapiTreeProxy", {
        //topLevelModels: me.topLevelModels,
        //childModels: me.childModels
      //});


    },

    onProxyLoad: function(operation) {
      var me = this;

      if (operation.success && !operation.node.parentNode) {
        me.totalProcessed = me.totalProcessed + operation.resultSet.length;
        me.totalCount = operation.totalResultCount;
      }

      me.callParent(arguments);
    },

    load: function load(options) {
      var me = this,
          ocb = options.callback;

      options.wsapi = {
        page: me.currentPage,
        start: (me.currentPage - 1) * me.pageSize,
        limit: me.pageSize,
        isPaging: true,
        query: me.query
      };

      //console.log("Tree Store Load Options");
      //console.dir(options);
      //console.log("Is Node Loaded?", options.node.isLoaded());


      options.callback = function updateTotals(nodes, ops, success) {
        //console.log("Tree Loaded", totalProcessed, arguments);

        if (ocb) {
          Ext.callback(ocb, options.scope || me, arguments);
        }
      };

      me.setProxy(Ext.create("Rally.data.WsapiTreeProxy", {
        model: options.node,
        topLevelModels: me.topLevelModels,
        childModels: me.childModels,
        isRoot: me.getRootNode().modelName === options.node.modelName,
        canExpandFn: me.canExpandFn,
        filterFn: me.filterFn,
        wsapiStoreOptions: options.wsapi
      }));

      me.callParent([options]);
    },

    getCount: function getCount() {
      return this.totalProcessed || 0;
    },

    getTotalCount: function getTotalCount() {
      return this.totalCount || 0;
    },

    loadPage: function loadPage(num, options) {
      this.currentPage = num;
      options = options || {};
      options.node = this.getRootNode();
      this.load(options);
    },

    nextPage: function nextPage(options) {
      this.loadPage(this.currentPage + 1, options);
    },

    previousPage: function previousPage(options) {
      this.loadPage(this.currentPage - 1, options);
    },

    getPageSize: function getPageSize() {
      return this.pageSize;
    }

  });
}(this));

                (function (global) {
  var appID = window.location.hash.split("/")[4];
  
  if (!appID) {
    appID = "0000000";
  }

  Ext.tree.ViewDropZone.prototype.getPosition = function(e, node) {
      var view = this.view,
          record = view.getRecord(node),
          y = e.getPageY(),
          noAppend = false, // removed check for isLeaf
          noBelow = false,
          region = Ext.fly(node).getRegion(),
          fragment;

      // If we are dragging on top of the root node of the tree, we always want to append.
      if (record.isRoot()) {
          return 'append';
      }

      // Return 'append' if the node we are dragging on top of is not a leaf else return false.
      if (this.appendOnly) {
          return noAppend ? false : 'append';
      }

      if (!this.allowParentInsert) {
          noBelow = record.hasChildNodes() && record.isExpanded();
      }

      fragment = (region.bottom - region.top) / (noAppend ? 2 : 3);
      if (y >= region.top && y < (region.top + fragment)) {
          return 'before';
      }
      else if (!noBelow && (noAppend || (y >= (region.bottom - fragment) && y <= region.bottom))) {
          return 'after';
      }
      else {
          return 'append';
      }
  };

  Ext.tree.View.prototype.getCellCls = function(record, column) {
      return Rally.ui.grid.CellClsDecorator.getCellCls(record, column);
  };

  Ext.define("Rally.ui.tree.grid.Panel", {
    extend: "Ext.tree.Panel",

    alias: "wiget.rallytreegrid",

    mixins: {
      messageable: "Rally.Messageable"
    },

    plugins: [
      { ptype: "rallyrefreshviewoncolumnchangeplugin" }
    ],

    config: {
      width: "100%",

      height: "100%",

      componentCls: "rallytree rally-grid",

      rootVisible: false,

      lines: false,

      viewConfig: {
        toggleOnDblClick: false,
        plugins: [
          { ptype: 'treeviewdragdrop' }
        ]
      }

    },

    treeColumnCfg: {
      xtype: 'treecolumn',
      text: 'ID',
      dataIndex: 'FormattedID',
      flex: 1
    },

    constructor: function rally_tree_grid_ctor(config) {
      var me = this,
          autoGenColumns,
          i, ii;

      if (config.columnCfgs && config.models) {
        config.columns = [me.treeColumnCfg];
        for (i = 0, ii = config.models.length; i < ii; i++) {
          autoGenColumns = Ext.create('Rally.ui.grid.ColumnBuilder')
            .withDefaultColumns(config.columnCfgs)
            .shouldAutoAddAllModelFieldsAsColumns(true)
            .build(config.models[i].superclass);

          //console.log("Auto Columns", autoGenColumns);
          config.columns = config.columns.concat(autoGenColumns);
        }
      }

      //this.plugins.push({ ptype: "rallycellediting", messageBus: this._getMessageBus() });

      delete config.models;
      delete config.columCfgs;

      //console.log("Column Config", config.columns);
      me.callParent(arguments);

      //console.log("Version", Ext.getVersion().version);

      me.getView().on("nodedragover", Ext.bind(me._canDragDrop, me)); // Waiting on 4.1.2
      me.getView().on("beforedrop", Ext.bind(me._onBeforeDrop, me));
    },


    _canDragDrop: function _canDragDrop(targetNode, position, dragData) {
      //console.log("Can Drag Drop", arguments);

      var rec = dragData.records[0],
          targetType,
          targetOrd = -1,
          sourceType,
          sourceOrd = -1;

      targetType = targetNode.raw._type.toLowerCase();
      sourceType = rec.raw._type.toLowerCase();

      if (targetType.indexOf("portfolioitem") >= 0) {
        targetOrd = targetNode.self.superclass.self.ordinal;
        targetType = targetType.split("/")[0];
      }

      if (sourceType.indexOf("portfolioitem") >= 0) {
        sourceOrd = rec.self.superclass.self.ordinal;
        sourceType = sourceType.split("/")[0];
      }

      if (sourceType === targetType === "portfolioitem") {
        if (targetOrd === sourceOrd + 1) {
          return true;
        } else {
          return false;
        }
      }

      if (sourceType === "hierarchicalrequirement") {
        if (targetType === "portfolioitem") {
          if (targetOrd === 0) {
            return true;
          } else {
            return false;
          }
        } else if (targetType === "hierarchicalrequriement") {
          return true;
        } else {
          return false;
        }
      }

      return false;
    },

    _onBeforeDrop: function _onBeforeDrop(elt, data, overModel, dropPosition, dropFunciton, eOpts) {
      //console.log("On Before Drop", arguments);
      var success = false;

      if (dropPosition === "append") {
        success = this._appendNodes.apply(this, arguments);
        overModel.data.leaf = false;
      } else if ((dropPosition === "before") || (dropPosition === "after")) {
        success = this._rerankNodes.apply(this, arguments);
      }

      return success;
    },

    _appendNodes: function _appendNodes(elt, data, overModel, dropPosition, dropFunction, eOpts) {
      var me = this,
          recs,
          success = true,
          i, ii,
          type;

      if (!data) {
        return false;
      }

      recs = data.records;
      for (i = 0, ii = recs.length; i < ii; i++) {
        type = recs[i].raw._type.toLowerCase();
        if (type.indexOf("portfolioitem") >= 0) {
          success = success && this._doReparentPI(overModel, recs[i]);
        } else if (type === "hierarchicalrequirement") {
          success = success && this._doReparentUS(overModel, recs[i]);
        } else if (type === "defect") {
          success = success && this._doReparentDE(overModel, recs[i]);
        } else if (type === "task") {
          success = success && this._doReparentTA(overModel, recs[i]);
        } else {
          success = false; // I don't know what you are
          //console.log("Don't know how to reparent this model", recs[i]);
        }
      }

      return success;
    },

    _doReparentPI: function _doReparentPI(parentModel, childModel) {
      var parentOrd,
          childOrd,
          parentTypeName,
          childTypeName;

      parentOrd = parentModel.self.superclass.self.ordinal;
      childOrd = childModel.self.superclass.self.ordinal;

      if (parentOrd !== childOrd + 1) {
        parentTypeName = parentModel.self.superclass.self.elementName;
        childTypeName = childModel.self.superclass.self.elementName;

        //Rally.ui.flair.FlairManager.showFlair({message: "A " + childTypeName + " cannot be the child of a " + parentTypeName});
        return false;
      } else {
        childModel.set("Parent", parentModel.raw._ref);
        childModel.save();
      }

      return true;
    },

    _doReparentUS: function _doReparentUS(parentModel, childModel) {
      var parentTypeName,
          parentOrd = -1;

      parentTypeName = parentModel.raw._type.toLowerCase();
      if (parentTypeName.indexOf("portfolioitem") >= 0) {
        parentOrd = parentModel.self.superclass.self.ordinal;
        if (parentOrd > 0) {
          return false;
        }

        childModel.set("PortfolioItem", parentModel.raw._ref);
        childModel.save();
      } else if (parentTypeName === "hierarchicalrequirement") {
        childModel.set("Parent", parentModel.raw._ref);
        childModel.save();
      } else {
        return false;
      }

      return true;
    },

    _doReparentTA: function _doReparentTA(parentModel, childModel) {
      if ({
        hierarchicalrequirement: 1, 
        defect: 1,
        defectsuite: 1,
        testset: 1}.hasOwnProperty(parentModel.raw._type.toLowerCase())) {

        if (parentModel.get("Children").length === 0) {
          childModel.set("WorkProduct", parentModel.raw._ref);
          childModel.save();

          return true;
        }
      }

      return false;
    },

    _doReparentDE: function _doReparentDE(parentModel, childModel) {
      var parentType = parentModel.raw._type.toLowerCase();
      if (parentType === "hierarchicalrequirement") {
        childModel.set("Requirement", parentModel.raw._ref);
        childModel.save();
        return true;
      } else if (parentType === "defectsuite") {
        childModel.set("DefectSuite", parentModel.raw._ref);
        childModel.save();
        return true;
      }

      return false;
    },

    _rerankNodes: function _rerankNode(elt, data, overModel, dropPosition, dropFunction, eOpts) {
      //console.log("ReRank", arguments);

      var rankType = dropPosition === "after" ? "rankBelow" : "rankAbove",
          params = {};

      params[rankType] = Rally.util.Ref.getRelativeUri(overModel.raw._ref);

      data.records[0].save({
        params: params
      });

      return true;
    }

  });
}(this));

                (function (global) {

  Ext.define("Rally.ui.renderer.template.PercentDoneByStoryPlanEstimateTemplate2", {
    extend: 'Ext.XTemplate',

    config: {
        /**
         * @cfg {String} width define a width if necessary to fit where it's being used
         */
        width: '100%',
        /**
         * @cfg {String} height define a height if necessary to fit where it's being used
         */
        height: '20px',
        /**
         * @cfg {String} percentDoneName sometimes it's necessary to name the variable used as the percent done replacement in the template,
         * like in a grid when a record is used to render the template. The record's field name might be 'PercentDoneByStoryCount', not 'percentDone'
         */
        percentDoneName: "PercentDoneByStoryPlanEstimate",
        

        /**
         * @cfg {Function} showDangerNotificationFn A function that should return true to show a triangle in the top right to denote something is missing.
         * Defaults to:
         *      function(){ return false; }
         */
        showDangerNotificationFn: function (recordData) {
          return (!recordData.PlannedEndDate && !recordData.ActualEndDate) || recordData.UnEstimatedLeafStoryCount > 0;
        },

        /**
         * @cfg {Boolean} If the percent done is 0%, do not show the bar at all
         */
        showOnlyIfInProgress: false
    },

    constructor: function(config) {
        this.initConfig(config);
        config = this.config;
        var me = this;
        var templateConfig = [
            '<tpl if="this.shouldShowPercentDone(values)">',
            '<div class="percentDoneContainer field-{[this.getPercentDoneName()]}" style="width: ' + config.width + '; height: ' + config.height + '; line-height: ' + config.height + '">',
            '<div class="percentDoneBar" style="background-color: {[this.calculateColor(values)]}; width: {[this.calculatePercent(values)]}; "></div>',
            '<tpl if="this.showDangerNotification(values)"><div class="percentDoneDangerNotification"></div></tpl>',
            '<div class="percentDoneLabel">',
            '{[this.calculatePercent(values)]}',
            '</div>',
            '</div>',
            '</tpl>',
            {
                shouldShowPercentDone: function(recordData) {
                  if (!Ext.isNumber(recordData[config.percentDoneName])) {
                    return false;
                  }

                  if (config.showOnlyIfInProgress) {
                    return recordData[config.percentDoneName] > 0;
                  } else {
                    return true;
                  }
                },
                calculatePercent: function(recordData) {
                    var percentDone = recordData[config.percentDoneName];
                    return Math.round(percentDone * 100) + '%';
                },
                calculateColor: function(recordData) {
                    var colorObject = Rally.util.HealthColorCalculator.calculateHealthColorForPortfolioItemData(recordData, me.getPercentDoneName());
                    return colorObject.hex;
                },
                showDangerNotification: config.showDangerNotificationFn
            }];
        /**
         * @param {Date}  config.startDate  (days since the epoch or date type where Tomorrow()-Today() = 1.0 (real))
         * @param {Date} config.endDate (same type as startDate)
         * @param {Date} config.asOfDate (same type as startDate) - Most often today. The naming of
         * @param {Boolean} config.inProgress
         */
        return this.callParent(templateConfig);
    }
  });

}(this));

                (function (global) {

  Ext.override(Rally.env.Server, {
    getWsapiUrl: function(version) {
      return this.getContextUrl() + "/webservice/1.43";
    }
  });

  
  var filterTags = [];
  
  var defaultFilterFn = function () { return true; };
  var defaultQuery = {property: 'ObjectID', operator: '!=', value: '0'};
  
    var tagFilterFn = function (rec) { 
        //console.log("tag Filter Fn",rec);
        //if (rec.data._type.toLowerCase() === "portfolioitem/theme") {
        if (rec.data._type.toLowerCase() === "portfolioitem/feature") {
        //if (rec.data._type.toLowerCase() === "portfolioitem/epic") {
            if ( filterTags.length > 0) {
                for ( var x = 0 ; x < rec.data.Tags.length;x++) {
                    for ( var y = 0 ; y < filterTags.length;y++) {
                        if ( rec.data.Tags[x]._ref == filterTags[y]._ref )
                            return true;
                    }
                }
                return false;
            } else {
                return true;
            }
        } else {
            return true;
        }
    };


  var renderTask = function renderTask(p, val, __, rec) {
    if (rec && rec.get) {
      if (rec.raw._type.toLowerCase() !== "task") {
        if (rec.raw.hasOwnProperty(p)) {
          return rec.raw[p];
        }
      }
    }

    return val;
  };

  Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',

    childTypes: {
      defect: false,
      task: false,
      testcase: false
    },

    mixins: {
      maskable: "Rally.ui.mask.Maskable"
    },

    loading: null,

    filterFn: defaultFilterFn,
    // filterTags : [],

    _queryFilter: defaultQuery,

    launch: function() {
      var me = this;

      me.maskTarget = me.el;

      me.showLoading();

      me.add(Ext.create("Ext.Panel", {
        border: false,
        layout: 'anchor',
        margin: '15 0 0 0',
        padding: '0 0 0 0',
        height: 75,
        width: '100%',
        items: [
          {
            width: '100%',
            anchor: '100% 45',
            border: false,
            layout: 'hbox',
            items: [
              {
                xtype: 'tbspacer',
                flex: 1
              },
              {
                // query string
                xtype: 'textareafield',
                itemId: 'query-textbox',
                fieldLabel: 'Query',
                labelAlign: 'right',
                width: 400,
                listeners: {
                  scope: me,
                  specialkey: function(field, e) {
                    if (e.getKey() == e.ENTER) {
                      me._applyQueryFilter();
                    }
                  }
                }
              },
              {
                // query trigger button
                xtype: 'rallybutton',
                text: 'Go',
                handler: me._applyQueryFilter,
                scope: me
              },
              {
                xtype: 'tbspacer',
                flex: 1
              },
              {
                xtype: 'rallymultiobjectpicker',
                fieldLabel: 'Tag',
                labelAlign: 'right',
                modelType: 'tag',
                listeners : {
                    collapse : function( field, eOpts ) {
                        //console.log("this",this);
                        //console.log("selected",field.getValue());
                        var cb = this.down("#typecb");
                        filterTags = field.getValue().length > 0 ?
                            field.getValue() : [];
                        this.filterFn = field.getValue().length > 0 ? 
                            tagFilterFn : defaultFilterFn;
                        this._applyFilter(cb);
                    },
                    scope : this
                }
              },
              {
                xtype: 'tbspacer',
                flex: 1
              },
              me._createTypeSelector(),
              {
                xtype: 'tbspacer',
                width: 10
              }
            ]
        }]
      }));
    },

    showLoading: function() {
      var me = this;

      me.showMask("Loading...");
    },

    hideLoading: function() {
      var me = this;

      me.hideMask();
    },

    _createTypeSelector: function _createViewSelector() {
      var cb = Ext.create("Rally.ui.combobox.PortfolioItemTypeComboBox", {itemId : "typecb"});

      cb.on("ready", function(value) { 
        //console.log("Loaded", arguments); 
        cb.on("change", this._applyFilter, this);
        this._applyFilter(cb, value);
      }, this);

      return cb;
    },

    _createTypeToStateFieldMap: function _createTypeToStateFieldMap(model) {
      //console.dir(model);

      var type = model.superclass.self.typePath.toLowerCase();
      var stateToFind = null;
      var ssf = null,
          i, ii,
          f;

      if (type.indexOf("portfolioitem/") >= 0) {
        stateToFind = "State";
      } else if ((type === "hierarchicalrequirement") || (type === "defect")) {
        stateToFind = "ScheduleState";
      } else if (type === "task") {
        stateToFind = "State";
      }

      if (stateToFind === null) {
        return null;
      }

      f = model.getFields();
      for (i = 0, ii = f.length; i < ii; i++) {
        if (f[i].name === stateToFind) {
          ssf = f[i];
          break;
        }
      }

      return ssf;
    },

    _applyQueryFilter: function() {
      var me = this;
      var queryString;
      var parser;
      var filter;
      var cb;

      queryString = me.down('#query-textbox').getValue();
      if(queryString) {
        parser = Ext.create('Rally.data.util.QueryStringParser', {
          string: queryString
        });
        try {
          filter = parser.parseExpression();
        }
        catch (err) {
          alert(err.toString());
          return;
        }
        //console.log('filter: ', filter.toString());
        me._queryFilter = filter;
      } else {
        me._queryFilter = defaultQuery;
      }
      cb = me.down('#typecb');
      me._applyFilter(cb);
    },

    _applyFilter: function _applyFilter(sender, newVal, oldVal, eOpts) {
      var i, ii;
      var me = this;

      this._types = [];
      this._childTypes = [];
      
      for (i = 0, ii = sender.store.data.items.length; i < ii; i++) {
        this._types.push(sender.store.data.items[i].data.TypePath.toLowerCase());
        this._childTypes.push(sender.store.data.items[i].data.TypePath.toLowerCase());
      }

      this._types.push("hierarchicalrequirement");
      this._types.push("task");
      this._types.push("defect");

      this._childTypes.push("hierarchicalrequirement");
      this._childTypes.push("task");
      this._childTypes.push("defect");

      this._childTypes.splice(0, sender.store.data.items.length - sender.valueModels[0].data.Ordinal);

      newVal = sender.valueModels[0].data;

      me.showLoading();

      if (this._treePanel) {
        this.remove(this._treePanel);
      }

      Rally.data.TreeModelFactory.getModels({
        types: me._types,
        success: function modelSuccess(models) {
          var m;

          me._stateFields = {};
          me.model = models[newVal.TypePath.toLowerCase()];

          for (m in models) {
            if (models.hasOwnProperty(m)) {
              me._stateFields[m] = me._createTypeToStateFieldMap(models[m]);
            }
          }

          //console.dir(me._stateFields);

          var doLoad = function(childModels) {
            //console.log("Child models", childModels);
            me.store = Ext.create('Rally.data.WsapiTreeStore', {
              topLevelModels: [ newVal.TypePath.toLowerCase() ],
              childModels: childModels,
              query: me._queryFilter,
              // barry : filter function
              filterFn: me.filterFn
            });

            me._onLoadData(newVal);
          };

          doLoad(me._childTypes);
        }
      });
    },

    _onLoadData: function _onLoadData(newVal) {
      var me = this;

      //console.log("Loading data", newVal);
      var appId = me.getAppId();

      var treefilterscfg = {
        ftype: 'treefilters',
        autoReload: false,
        local: true,
        filters: [{
          type: 'string',
          dataIndex: 'Name'
        }]
      };

      me._treePanel = Ext.create('Rally.ui.tree.grid.Panel', {
        store: me.store,
        features: [treefilterscfg],
        models: [me.model],
        stateful: true,
        stateId: 'portfoliodrilldown-treegrid-' + appId,
        dockedItems: [{
          xtype: 'rallypagingtoolbar',
          store: me.store,   // same store TreeGridPanel is using
          dock: 'bottom',
          displayInfo: true,
          listeners: {
            beforechange: function () {
              this.showLoading();
            },
            scope: me
          }
        }],
        listeners: {
          load: function() { me.hideLoading(); }
        },
        columnCfgs: [
          "Name",
          "Priority",
          "PreliminaryEstimate",
        //   "Release",
            {
                dataIndex : 'Release',
                text: 'Release',
                renderer: function (value, metaData, record) {
                    return value !== undefined && value !== null ? value._refObjectName : null;                    
                }
            },
           {
            xtype: 'templatecolumn',
            tpl: Ext.create('Rally.ui.renderer.template.PercentDoneByStoryPlanEstimateTemplate2'),
            text: '% Done By Plan Estimate',
            dataIndex: 'PercentDoneByPlanEstimate'
            //flex: 1
          }, {
            xtype: 'templatecolumn',
            tpl: Ext.create('Rally.ui.renderer.template.PercentDoneByStoryPlanEstimateTemplate2', {
              percentDoneName: 'PercentDoneByStoryCount'
            }),
            text: '% Done By Story Count',
            dataIndex: 'PercentDoneByStoryCount'
            //flex: 1
          },
          "AcceptedLeafStoryCount",
          "LeafStoryCount",
          "LeafStoryPlanEstimateTotal",
            {
                text: 'PlanEstimate',
                dataIndex: 'PlanEstimate',
                flex: 1
            },
          "ScheduleState",
          {
            text: 'Task Est.',
            dataIndex: 'Estimate',
            renderer: Ext.bind(renderTask, me, ["TaskEstimateTotal"], 0),
            //flex: 1,
            hidden: true
          },
          {
            text: 'To Do',
            dataIndex: 'ToDo',
            renderer: Ext.bind(renderTask, me, ["TaskRemainingTotal"], 0),
            //flex: 1,
            hidden: true
          }, 
            {
                text: 'State',
                renderer: function (value, metaData, record) {
                    var type = record.data._type.toLowerCase();
                    var res = "";
                    res = me._stateFields[type].renderTpl.apply(record.data);
                    return res;
                }
            },
            "PlanEstimate"
        ]

      });

      me._treePanel.on("load", function() { me.hideLoading(); });
      me.add(me._treePanel);
    }
  });
}(this));


            Rally.launchApp('CustomApp', {
                name:"TreeGrid",
	            parentRepos:""
            });

        });
    </script>


    <style type="text/css">
        .app {
     /* Add app styles here */
}

.x-tree-no-lines .x-tree-elbow {
  background-color: transparent;
}

/* line 6, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-no-lines .x-tree-elbow-end {
  background-color: transparent;
}

/* line 10, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-no-lines .x-tree-elbow-line {
  background-color: transparent;
}

/* line 15, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-arrows .x-tree-elbow-plus {
  background: transparent no-repeat 0 0;
}

/* line 19, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-arrows .x-tree-elbow-end-plus {
  background: transparent no-repeat 0 0;
}

/* line 23, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-arrows .x-tree-elbow-end-minus {
  background: transparent no-repeat -16px 0;
}

/* line 27, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-arrows .x-tree-elbow-minus {
  background: transparent no-repeat -16px 0;
}

/* line 31, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-arrows .x-tree-elbow {
  background-color: transparent !important;
}

/* line 35, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-arrows .x-tree-elbow-end {
  background-color: transparent !important;
}

/* line 39, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-arrows .x-tree-elbow-line {
  background-color: transparent !important;
}

/* line 45, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-arrows .x-tree-expander-over .x-tree-elbow-plus,
.x-tree-arrows .x-tree-expander-over .x-tree-elbow-end-plus {
  background-position: -32px 0;
}

/* line 50, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-arrows .x-tree-expander-over .x-tree-elbow-minus,
.x-tree-arrows .x-tree-expander-over .x-tree-elbow-end-minus {
  background-position: -48px 0;
}

/* line 55, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-arrows .x-grid-tree-node-expanded .x-tree-elbow-plus,
.x-tree-arrows .x-grid-tree-node-expanded .x-tree-elbow-end-plus {
  background-position: -16px 0;
}

/* line 60, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-arrows .x-grid-tree-node-expanded .x-tree-expander-over .x-tree-elbow-plus,
.x-tree-arrows .x-grid-tree-node-expanded .x-tree-expander-over .x-tree-elbow-end-plus {
  background-position: -48px 0;
}

/* line 67, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-elbow-plus,
.x-tree-elbow-minus,
.x-tree-elbow-end-plus,
.x-tree-elbow-end-minus {
  cursor: pointer;
}

/* line 73, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-lines .x-tree-elbow {
  background-image: url('/apps/2.0p2/ext/4.0.7/resources/themes/images/default/tree/elbow.gif');
}
/* line 77, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-lines .x-tree-elbow-end {
  background-image: url('/apps/2.0p2/ext/4.0.7/resources/themes/images/default/tree/elbow-end.gif');
}
/* line 81, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-lines .x-tree-elbow-plus {
  background-image: url('/apps/2.0p2/ext/4.0.7/resources/themes/images/default/tree/elbow-plus.gif');
}
/* line 85, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-lines .x-tree-elbow-end-plus {
  background-image: url('/apps/2.0p2/ext/4.0.7/resources/themes/images/default/tree/elbow-end-plus.gif');
}
/* line 89, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-lines .x-grid-tree-node-expanded .x-tree-elbow-plus {
  background-image: url('/apps/2.0p2/ext/4.0.7/resources/themes/images/default/tree/elbow-minus.gif');
}
/* line 93, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-lines .x-grid-tree-node-expanded .x-tree-elbow-end-plus {
  background-image: url('/apps/2.0p2/ext/4.0.7/resources/themes/images/default/tree/elbow-end-minus.gif');
}
/* line 97, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-lines .x-tree-elbow-line {
  background-image: url('/apps/2.0p2/ext/4.0.7/resources/themes/images/default/tree/elbow-line.gif');
}

/* line 104, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-no-lines .x-tree-elbow-plus,
.x-tree-no-lines .x-tree-elbow-end-plus {
  background-image: url('/apps/2.0p2/ext/4.0.7/resources/themes/images/default/tree/elbow-plus-nl.gif');
}
/* line 109, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-no-lines .x-grid-tree-node-expanded .x-tree-elbow-plus,
.x-tree-no-lines .x-grid-tree-node-expanded .x-tree-elbow-end-plus {
  background-image: url('/apps/2.0p2/ext/4.0.7/resources/themes/images/default/tree/elbow-end-minus-nl.gif');
}

/* line 118, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-arrows .x-tree-elbow-plus,
.x-tree-arrows .x-tree-elbow-minus,
.x-tree-arrows .x-tree-elbow-end-plus,
.x-tree-arrows .x-tree-elbow-end-minus {
  background-image: url('/apps/2.0p2/ext/4.0.7/resources/themes/images/default/tree/arrows.gif');
}

/* line 123, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-icon {
  margin-right: 3px;
}

/* line 132, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-elbow,
.x-tree-elbow-end,
.x-tree-elbow-plus,
.x-tree-elbow-end-plus,
.x-tree-elbow-empty,
.x-tree-elbow-line {
  height: 18px;
  width: 16px;
}

/* line 137, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-icon-leaf {
  width: 16px;
  background-image: url('/apps/2.0p2/ext/4.0.7/resources/themes/images/default/tree/leaf.gif');
}

/* line 142, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-tree-icon-parent {
  width: 16px;
  background-image: url('/apps/2.0p2/ext/4.0.7/resources/themes/images/default/tree/folder.gif');
}

/* line 147, /apps/2.0p2/ext/4.0.7/resources/themes/stylesheets/ext4/default/widgets/_tree.scss */
.x-grid-tree-node-expanded .x-tree-icon-parent {
  background-image: url('/apps/2.0p2/ext/4.0.7/resources/themes/images/default/tree/folder-open.gif');
}

.x-tree-icon-leaf, .x-tree-icon-parent, .x-grid-tree-node-expanded .x-tree-icon-parent {
  background: url(/slm/images/icon_portfolio_item.gif);
}

.portfolioitem .x-tree-icon {
  background: url(/slm/images/icon_portfolio_item.gif);	
}

.hierarchicalrequirement .x-tree-icon {
  background: url(/slm/images/icon_story.gif);	
}

.task .x-tree-icon {
  background: url(/slm/images/icon_task.gif);	
}

.defect .x-tree-icon {
  background: url(/slm/images/icon_defect.gif);	
}

.testcase .x-tree-icon {
  background: url(data:image/gif;base64,R0lGODlhEAAQAMQWAEaiGcvLy2VmmEeiGWZlmWVlmZjLfzOZAP7//mVlmJnLf0ejGWZmmmRll2VmmXa6VLXaozOYADKYAMzMzGZmmf///////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAABYALAAAAAAQABAAAAV7oGVBDwA8kKiuRiRJkWusKvRWOC6l9PMeMN2D0HAQKAkAzFWRNAc5HGUQOzSdkkUlMJlUCg+mK9J8RCsUW+zFhlS6XorF8BpHFIizfPQYnCAIXHBoKwxnZw4rFFuDAhQODnsii2cFUjQCb4IVmZIqlnqeKgQOjhSniSohADs=)
}


    </style>
</head>
<body></body>
</html>
